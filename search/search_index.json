{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>IceNvim is a beautiful, powerful and customizable neovim config that is blazing fast. It can be used on MacOS / Windows / Linux.</p> <ul> <li>\ud83d\udcbb Supports development with a variety of programming languages and frameworks</li> <li>\ud83e\udd16 Embraces the power of AI by integrating with your favorite LLMs during development</li> <li>\ud83d\udd8a\ufe0f Offers an enhanced editing experience using popular plugins</li> <li>\ud83d\udd27 Ships with multiple useful tools out of the box</li> <li>\ud83c\udc04\ufe0f Automatic IME switching functionality for Chinese users when switching modes</li> <li>\ud83d\ude80 Enhancing features like clipboard support on windows and automatic directory switching</li> <li>\ud83c\udf0a You can customize literally anything without messing up the original git repo</li> </ul>"},{"location":"#showcase","title":"Showcase","text":""},{"location":"installation/","title":"Installation","text":"<p>IceNvim requires the latest stable version of neovim to run. This means that you will need neovim &gt;= 0.11.0.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>To get IceNvim running, you need to have these dependencies installed: </p> <ul> <li>git</li> <li>a nerd font</li> <li>curl</li> <li>fd</li> <li>gcc</li> <li>cmake</li> <li>gzip or 7zip</li> <li>node and npm</li> <li>tree-sitter-cli</li> <li>yarn</li> <li>python3 and pip3</li> <li>ripgrep</li> <li>wget</li> </ul> <p>Also, if you are using Linux, you will be needing these:</p> <ul> <li>unzip</li> <li>python virtual environment</li> <li>xclip (not required on WSL)</li> <li>zip</li> </ul> Installing dependencies on different systems  MacOS:  <pre><code>brew install wget fd ripgrep node yarn cmake tree-sitter-cli\n</code></pre>  Arch:  <pre><code>sudo pacman -S --needed curl gzip wget fd ripgrep gcc nodejs npm python python-pip unzip zip xclip python-virtualenv tree-sitter-cli\n</code></pre>  Windows (via scoop):  <pre><code>scoop install curl gzip wget fd ripgrep mingw nodejs-lts python\n</code></pre>"},{"location":"installation/#installing-icenvim","title":"Installing IceNvim","text":"<p>On Windows:</p> <p><code>git clone https://github.com/Shaobin-Jiang/IceNvim \"$env:LOCALAPPDATA\\nvim\"</code></p> <p>On MacOS / Linux:</p> <p><code>git clone https://github.com/Shaobin-Jiang/IceNvim ~/.config/nvim</code></p> <p>As a precaution, you should check whether the prerequisites from the previous section are all installed. Of course, missing dependencies does not really crash your computer, but it does make hell of a mess. Therefore, when the cloning is done, start neovim with <code>nvim --noplugin</code> and run the <code>:IceHealth</code> command. It should inform you of any missing dependency.</p> <p></p> <p>You can also check whether the nerd font is correctly used by running the <code>IceCheckIcons</code> command, which ought to display the icons like below:</p> <p></p> <p>With everything ready, you can now restart neovim with <code>nvim</code> (no <code>noplugin</code> flag this time). IceNvim will automatically install some plugins for you, as well as treesitter parsers and language servers. Wait till these are finished, and you can get started with using IceNvim.</p>"},{"location":"installation/#optional-installation","title":"Optional Installation","text":""},{"location":"installation/#automatic-ime-switching","title":"Automatic IME Switching","text":"<p>For users who use IME a lot, switching modes in neovim can be a pain in the ***. IceNvim deals with this by automatically switching the input method to English when it is not in insert mode.</p> <p>For Windows / WSL, to enable this functionality, im-select.exe will be needed. Place the executable in the <code>bin</code> directory in the neovim configuration directory. You will need to create one if there is no such directory.</p> <p>Additionally, if you are using wsl, you might have to do this:</p> <pre><code>chmod +x ~/.config/nvim/bin/im-select.exe\n</code></pre> <p>For MacOS, you will need to install macism. It can be installed with homebrew:</p> <pre><code>brew tap laishulu/homebrew\nbrew install macism\n</code></pre> <p>For Linux, IME switching is also supported for Fcitx5.</p>"},{"location":"installation/#unicode-yanking","title":"Unicode Yanking","text":"<p>Although text yanked from within IceNvim is already available from outside, one might find that utf-8 characters are not copied properly on Windows and WSL. This is because the functionality is dealt with by Windows' <code>CLIP</code> command which does a poor job when used with unicode characters.</p> <p>To solve this, one might need to download uclip.exe and place it in the <code>bin</code> directory in the neovim configuration directory.</p> <p>Additionally, if you are using wsl, you might have to do this:</p> <pre><code>chmod +x ~/.config/nvim/bin/uclip.exe\n</code></pre>"},{"location":"installation/#language-specific-installation","title":"Language-Specific Installation","text":""},{"location":"installation/#c-development","title":"C# Development","text":"<p>IceNvim uses Omnisharp and Csharpier for C# development. If you want to use IceNvim for C# development, make sure that you have dotnet sdk installed.</p> <p>If you are receiving nuget-related errors when installing csharpier, you might have to configure nuget source by running this command:</p> <pre><code>dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org\n</code></pre>"},{"location":"installation/#rust-development","title":"Rust Development","text":"<p>If you want to use IceNvim for rust development, you will need to install rust-analyzer. The recommended way is to install rustup.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#mason-registry-refreshing-failed","title":"Mason Registry Refreshing Failed","text":"<p>This might be due to the use of proxies. Shut down softwares of such kind and run the <code>:Mason</code> command. The interface that pops up will prompt you on how to refresh the registry again.</p>"},{"location":"qa/","title":"Q&A","text":""},{"location":"qa/#do-i-need-to-be-familiar-with-neovim-to-start-using-icenvim","title":"Do I need to be familiar with neovim to start using IceNvim?","text":"<p>The answer is affirmative. You need at least some knowledge with neovim to get started with IceNvim because it is, after all, a neovim configuration, differing considerably from editors like Visual Studio Code or Intellij IDEA.</p> <p>The good news is that you do not need to be an expert (and frankly, experts do not use other people's configuration anyway). I would say that being familiar with the very basic editing in neovim would suffice, like cursor movement, mode switching, etc.</p> <p>It would be even better if you know how to configure neovim, like knowing how to use lazy.nvim and creating autocmds, as you would be able to further customize IceNvim, making it even more powerful and to your taste.</p> <p>Note</p> <p>If you are a Chinese user, I would recommend my tutorial on bilibili to get you started with neovim.</p>"},{"location":"qa/#why-should-i-choose-icenvim","title":"Why should I choose IceNvim?","text":"<p>Let's not mention just how powerful IceNvim already is. What I am really proud for IceNvim about is the infinite possibility it grants. You can customize literally anything and not worry about making a mess of the original git repo. You could compare it to ArchLinux perhaps, which sets up a sound basis for you to add to and modify whatever you might like.</p>"},{"location":"qa/#is-there-no-dap-support","title":"Is there no DAP support?","text":"<p>No. And that is intentional, since I do not use that and have no idea how to include it in my workflow.</p>"},{"location":"qa/#do-i-need-to-update-plugins-tree-sitter-parsers-lsps-myself","title":"Do I need to update plugins / tree-sitter parsers / LSPs / ... myself?","text":"<p>Yes. IceNvim does not force you to update anything unless you feel the necessity to do so. Hard as it is to believe, it is a luxry for many neovim users to access GitHub, and since almost everything included in IceNvim is downloaded from there, it would be a pain in the a** if updating is too frequent.</p>"},{"location":"qa/#how-do-i-contribute-to-icenvim-this-documentation","title":"How do I contribute to IceNvim / this documentation?","text":"<p>Contribution is welcome. Just open a pull request even if it is as simple as a typo fix.</p> <p>Or, if you want a certain feature or to fix a bug but does not know how to implement that, open an issue or discussion.</p>"},{"location":"customization/basic/","title":"Basic","text":"<p>You can configure some of the basic features of IceNvim which functions without plugins.</p>"},{"location":"customization/basic/#keymaps","title":"Keymaps","text":"<p>You can customize keymaps via the <code>Ice.keymap</code> table. Note that these do not include plugin-related keymaps. Those can be modified via the <code>keys</code> table in a plugin config spec or, for some plugins, via the <code>opts</code> table.</p> <p>Each item in the <code>Ice.keymap</code> table is a table that consists of the arguments passed to <code>vim.keymap.set</code>. That is, it contains: <code>mode</code> / <code>lhs</code> / <code>rhs</code> / (optional) <code>opts</code>. The name for each item is converted to the <code>desc</code> option for that keymap. For example, I have this in my custom config that opens a url in qutebrowser:</p> <pre><code>Ice.keymap.open_in_qutebrowser = {\n    { \"n\", \"v\" },\n    \"&lt;leader&gt;uq\",\n    function()\n        local mode = vim.api.nvim_get_mode().mode\n\n        local target = \"\"\n        if mode == \"n\" then\n            target = vim.fn.expand \"&lt;cWORD&gt;\"\n        else\n            local start_pos = vim.fn.getpos \"'&lt;\"\n            local end_pos = vim.fn.getpos \"'&gt;\"\n            local selection = vim.fn.getregion(start_pos, end_pos)\n            if #selection == 1 then\n                target = selection[1]\n            end\n        end\n\n        local url = string.match(target, \"[%w]+://[%w-_%.%?%.:/%+=&amp;]+\")\n        if url ~= nil then\n            vim.system { \"qutebrowser\", url, \"--target\", \"tab\" }\n        else\n            vim.notify(\"Target is not a valid url\", vim.log.levels.WARN)\n        end\n    end,\n}\n</code></pre> <p>This would add an entry with the desc \"open in qutebrowser\" in which-key.</p>"},{"location":"customization/basic/#filetype-specific-configuration","title":"FileType-Specific Configuration","text":"<p>Of course we can do this via neovim's ftplugin feature. No big deal. That, however, requires you to write vimscript, which I am strongly against under most scenarios. IceNvim provides a seperate interface instead: <code>Ice.ft[\"&lt;filetype&gt;\"]</code>.</p> <p>For example, you can do this:</p> <pre><code>Ice.ft.lua = function()\n    vim.wo.colorcolumn = \"120\"\nend\n</code></pre> <p>This has the down side, though, of overriding any filetype-specific configuration IceNvim has made. Another approach would be to use the <code>Ice.ft:set</code> method. For example:</p> <pre><code>Ice.ft:set(\"python\", function()\n    vim.cmd \"compiler python\"\n    vim.keymap.set(\"n\", \"&lt;F9&gt;\", \":silent make | copen&lt;CR&gt;\", { buffer = 0 })\nend)\n</code></pre>"},{"location":"customization/basic/#automatic-directory-switching","title":"Automatic Directory Switching","text":"<p>IceNvim automatically switches the cwd to your project directory if possible. It works better than neovim's default <code>autochdir</code>. However, if you do not like this feature, you can disable it by doing this:</p> <pre><code>Ice.auto_chdir = false\n</code></pre> <p>By default, it is disabled for buffers with the filetype of <code>NvimTree</code> and <code>help</code> and with the buftype of <code>terminal</code> and <code>nofile</code>. You can override these options via the <code>Ice.chdir_exclude_filetype</code> and <code>Ice.chdir_exclude_buftype</code> tables.</p> <p>IceNvim automatically switches dir by trying to detect for certain file / directory patterns: <code>.git</code> / <code>package.json</code> / <code>.prettierrc</code> / <code>tsconfig.json</code> / <code>pubspec.yaml</code> / <code>.gitignore</code> / <code>stylua.toml</code> / <code>README.md</code>. You can override this via the <code>Ice.chdir_root_pattern</code> table.</p> <p>Warning</p> <p><code>Ice.chdir_exclude_filetype</code>, <code>Ice.chdir_exclude_buftype</code> and <code>Ice.chdir_root_pattern</code> do not exist by default! You can only set their value but cannot modify their values initially.</p>"},{"location":"customization/get-started/","title":"Getting Started","text":"<p>IceNvim grants you almost infinite ability to customize. This sounds like no big deal, but what is special about this is that IceNvim allows you to do so without messing the original repo.</p> <p>Some neovim distros \"allow\" you to override the defaults by directly modifying the original config files. This messes the git repo and makes keeping track of upstream updates somewhat difficult. IceNvim uses a different approach by introducing a <code>custom</code> module in the config dir. The entire directory is not tracked by git and by placing any customization code inside this dir, you can modify the default behaviors of IceNvim while also being able to keep up with any update made upstream.</p> <p>This page and the rest parts in this section will show to you how to utilize this great customization ability.</p>"},{"location":"customization/get-started/#how-the-custom-module-works","title":"How the <code>custom</code> Module Works","text":"<p>If you have taken a look at the directory structure of the IceNvim config, you can see that it looks something like this:</p> <pre><code>\ud83d\udcc2 nvim\n|-- \ud83d\udcc2 lua\n    |-- \ud83d\udcc2 core\n    |-- \ud83d\udcc2 custom\n    |-- \ud83d\udcc2 lsp\n    |-- \ud83d\udcc2 plugins\n|-- \ud83d\udcc2 screenshots\n|-- \ud83d\udcc4 .gitignore\n|-- \ud83d\udcc4 .stylua.toml\n|-- \ud83d\udcc4 LICENSE\n|-- \ud83d\udcc4 README.md\n|-- \ud83d\udcc4 init.lua\n</code></pre> <p>IceNvim first loads the config in <code>core</code> which includes basic functions that do not require a plugin. If you run neovim with the <code>--noplugin</code> flag, by default only the configuration in here is used.</p> <p>The <code>lsp</code> and <code>plugins</code> modules are both responsible for functions that are only available when plugins are enabled. These two modules are loaded after <code>core</code>. However, when I say \"loaded\" here, I am not talking about the loading of plugins. Rather, what these modules do is storing the configuration spec (for details, you might check the documentation of lazy.nvim) in a global variable called <code>Ice</code>.</p> <p>What comes last is the <code>custom</code> module. Here, you can make modifications to options that come with neovim (such as fields in <code>vim.o</code> and <code>vim.g</code>) as well as the <code>Ice</code> table. Since <code>custom</code> comes after <code>core</code>, <code>plugins</code> and <code>lsp</code>, any default settings made by IceNvim in these modules can be overridden.</p> <p>After <code>custom</code> loaded, we have a final <code>Ice</code> table. Now, IceNvim will use this table to load plugins, set keymaps, etc.</p> <p>Warning</p> <p>Again, I must stress the fact that plugins are not yet available when <code>custom</code> files are loaded. This means that, should you use functionalities that require a plugin in your <code>custom</code> files, it would not work and some hedious errors would be thrown causing IceNvim to cease to work. For example, this is bad:</p> <pre><code>Ice.plugins.hop.opts.hint_position = require(\"hop.hint\").HintPosition.END\n</code></pre> <p>As said above, <code>hop</code> is currently not loaded and neovim cannot find a module named <code>hop.hint</code>. You have two options to avoid this. Option 1 is removing the module:</p> <pre><code>Ice.plugins.hop.opts.hint_position = 3 -- equal to require(\"hop.hint\").HintPosition.END\n</code></pre> <p>Option 2 is to postpone the calling to the module. For example, you can use the <code>config</code> function to load the plugin:</p> <pre><code>Ice.plugins.hop.config = function (_, opts)\n    opts.hint_position = require(\"hop.hint\").HintPosition.END\n    require(\"hop\").setup(opts)\nend\n</code></pre>"},{"location":"customization/get-started/#getting-started-with-the-custom-module","title":"Getting Started with the <code>custom</code> Module","text":"<p>You can place any number of files inside <code>custom</code>, but one <code>init.lua</code> file is essential. Do not worry, though. Even if it is missing, IceNvim will create it for you.</p> <p>But there is more to that. We know that neovim looks for such folders as <code>queries</code>, <code>compiler</code>, <code>spell</code>, etc., in your <code>runtimepath</code>. Typically, if one wishes to override the default treesitter queries or ftplugins or other things already set up by neovim, they would need to create the corresponding directory under their config directory.</p> <p>However, IceNvim users do not need to do that. IceNvim has added <code>custom</code> to <code>runtimepath</code> so you can just create these folders there. For example, where you should have <code>~/.config/nvim/queries/markdown/highlights.scm</code>, with IceNvim, it should be placed at <code>~/.config/nvim/queries/lua/custom/queries/markdown/highlights.scm</code>:</p> <pre><code>\ud83d\udcc2 nvim\n|-- \ud83d\udcc2 lua\n    |-- \ud83d\udcc2 core\n    |-- \ud83d\udcc2 custom\n        |-- \ud83d\udcc4 init.lua\n        |-- \ud83d\udcc2 queries\n            |-- \ud83d\udcc2 markdown\n                |-- \ud83d\udcc4 highlights.scm\n    |-- \ud83d\udcc2 lsp\n    |-- \ud83d\udcc2 plugins\n</code></pre>"},{"location":"customization/plugins/","title":"Plugins","text":"<p>You can customize the plugins via the <code>Ice.plugins</code> table.</p>"},{"location":"customization/plugins/#customizing-a-plugin","title":"Customizing a Plugin","text":"<p>Each plugin installed corresponds to a key-value pair in <code>Ice.plugins</code>. For example, if you want to customize <code>hop.nvim</code>, just make modifications to <code>Ice.plugins.hop</code>. The names used in <code>Ice.plugins</code> can be found in the utilities/plugins section, but with auto-completion enabled default, you can just navigate through the completion menu after typing <code>Ice.plugins.</code> to find the field name of a certain plugin.</p> <p>Each value in these pairs is a lazy.nvim-compatible plugin spec. Pretty much everything is the same as when you are using lazy, but instead of returning it, we are storing it in <code>Ice.plugins</code>.</p> <p>You can also remove a plugin by setting it to <code>nil</code> or add a plugin that is not present in IceNvim.</p> <p>For example:</p> <pre><code>local view = Ice.plugins[\"nvim-tree\"].opts.view\nview.number = true\nview.relativenumber = true\n\nIce.plugins.bufferline = nil -- disables bufferline\n\n-- Field name does not matter when adding a new plugin\nIce.plugins.aaa = {\n    \"folke/zen-mode.nvim\",\n}\n</code></pre> <p>Warning</p> <p>Most of the time, IceNvim only uses configuration included by the original plugin. The only exception is nvim-treesitter.</p> <p>In a recent update, nvim-treesitter removed the <code>ensure_installed</code> field. IceNvim, however, persists on using this field to automatically install parser. It is also highly unrecommended to use other ways to install parser, e.g., via the <code>TSInstall</code> command, because IceNvim has made special tweaks to only enable treesitter support for buffers whose filetype has a corresponding parser.</p> <p>For example, you can install the parser for swift like this:</p> <pre><code>table.insert(Ice.plugins[\"nvim-treesitter\"].opts.ensure_installed, \"swift\")\n</code></pre>"},{"location":"customization/plugins/#lazy-loading-a-plugin","title":"Lazy Loading a Plugin","text":"<p>If you are familiar with lazy.nvim, you should know about the <code>VeryLazy</code> event and how it is used to lazy load a plugin. IceNvim is built with performance in mind and also further provides some custom events to help boost loading.</p>"},{"location":"customization/plugins/#iceload-event","title":"<code>IceLoad</code> Event","text":"<p><code>IceLoad</code> is triggered after the colorscheme is loaded and well after the <code>VeryLazy</code> event. However, if the current buffer is an unnamed buffer or it is the dashboard, the triggering of <code>IceLoad</code> will be postponed to the next time we enter a buffer. If the next buffer is still a dashboard / unnamed buffer, the triggering is further postponed.</p> <p>Note that <code>IceLoad</code> is a custom event, so when using it in the lazy.nvim <code>event</code> field, it should be prefixed with a <code>User</code>. For example:</p> <pre><code>Ice.plugins.bufferline.event = \"User IceLoad\"\n</code></pre>"},{"location":"customization/plugins/#iceafter-event","title":"<code>IceAfter</code> Event","text":"<p><code>IceAfter</code> is intended for scenarios where the loading order of two plugins are critical.</p> <p>For example, in IceNvim, rainbow-delimiter loads with nvim-treesitter as it requires a tree-sitter parser to work. Another plugin, indent-blankline, requires rainbow-delimiter to load first to enable colorful indentation markers. Therefore, IceNvim needs to ensure that indent-blankline loads after nvim-treesitter.</p> <p>With <code>IceAfter</code>, this would be easy. You can just fire a <code>User IceAfter nvim-treesitter</code> event after nvim-treesitter is loaded and set the <code>event</code> for indent-blankline to <code>User IceAfter nvim-treesitter</code>:</p> <pre><code>Ice.plugins[\"nvim-treesitter\"] = {\n    -- ...\n    config = function (_, opts) {\n      -- Setting up nvim-treesitter\n      vim.api.nvim_exec_autocmds(\"User\", { pattern = \"IceAfter nvim-treesitter\" })\n    },\n}\n\nIce.plugins[\"indent-blankline\"].event = \"User IceAfter nvim-treesitter\"\n</code></pre> <p>IceNvim also fires the <code>IceAfter colorscheme</code> after the colorscheme is set, so you can also use <code>User IceAfter colorscheme</code> to load a plugin after the colorscheme is ready (differing from <code>IceLoad</code> in that this does not care about whether you are viewing the dashboard).</p>"},{"location":"customization/plugins/#language-specific-configuration","title":"Language-Specific Configuration","text":"<p>As mentioned above, you can disable any plugin by setting the corresponding field to <code>nil</code>. However, it would be better if you use a different approach with a few of them. These plugins are exclusively responsible for development in a certain language, and IceNvim has a different mechanism for managing them.</p> <p>IceNvim supports development for these languages: Bash / C / C++ / C# / Flutter / Go / CSS / HTML / JavaScript / Typescript / JSON / Lua / Python / Typst / Rust. Among these, some are managed by plugins while others are supported via LSPs and formatters. To provide a universal interface to managing them, IceNvim introduces the <code>Ice.lsp</code> table. Each language corresponds to a field in this table:</p> <ul> <li><code>emmet-ls</code></li> <li><code>pyright</code>: python</li> <li><code>tinymist</code>: typst</li> <li><code>bash-language-server</code></li> <li><code>rust</code></li> <li><code>gopls</code>: go</li> <li><code>clangd</code>: C / C++</li> <li><code>css-lsp</code></li> <li><code>typescript-language-server</code></li> <li><code>html-lsp</code></li> <li><code>json-lsp</code></li> <li><code>lua-language-server</code></li> <li><code>omnisharp</code>: C#</li> <li><code>flutter</code></li> </ul> <p>By default, only <code>lua-language-server</code> is enabled. To enable support for a language, just set <code>enabled = true</code>:</p> <pre><code>Ice.lsp.flutter.enabled = true\n</code></pre> <p>And if you want to enable support for all these languages above, just do this:</p> <pre><code>for _, lsp in pairs(vim.tbl_keys(Ice.lsp)) do\n    Ice.lsp[lsp].enabled = true\nend\n</code></pre> <p>Each language has a config table. If the table has <code>managed_by_plugin = true</code>, that language is managed by a plugin, and configuration for that language go to the corresponding <code>Ice.plugins</code> table:</p> <ul> <li>flutter: flutter-tools</li> <li>rust: rustaceanvim</li> </ul> <p>Others are managed by LSPs and formatters. In this case, each table can optionally have a <code>formatter</code> and a <code>setup</code> field, where <code>formatter</code> is the name you can find by running the command <code>Mason</code> and <code>setup</code> is the configuration available to the language server. You can find out how to configure the latter value for specific languages here (most of the time you really do not need that, though).</p> <p>Note</p> <p>The <code>setup</code> value is actually of <code>vim.lsp.Config</code> type and so you can check out what values you can use by running <code>:h vim.lsp.Config</code>.</p> <p>The exception, though, is the <code>on_attach</code> function. This function runs when the lsp is attached to the buffer and takes two arguments, which are the active client and the buffer id. For example, you can do something like this:</p> <pre><code>Ice.lsp.omnisharp.setup.on_attach = function(client, bufnr)\n    client.server_capabilities.semanticTokensProvider = nil\nend\n</code></pre> <p>This is added for compatibility concerns since back in the days when people use nvim-lspconfig to configure language servers, such a value was provided. Neovim's new lsp api renders setting up lsp with nvim-lspconfig unnecessary, but as <code>on_attach</code> is not something provided by the former, migrating from one's old configuration would prove troublesome.</p> <p>Just for some background reading, IceNvim actually implements <code>on_attach</code> via the <code>LspAttach</code> event. An alternative would have been to not implement this at all and instead ask the user to write their own autocmds, but that would be rather messy compared with the old way using <code>on_attach</code>.</p> <p>You might notice that some of these languages have strange names. Why not just name it <code>bash</code> instead of <code>bash-language-server</code>? That is because these are names from <code>Mason</code> LSPs. Should you wish to add support for other languages without using a plugin, you should use the name of the LSP from <code>Mason</code> as its field name. For example, haskell's LSP is named <code>haskell-language-server</code> if you look it up in Mason. To add support for haskell, do this:</p> <pre><code>Ice.lsp[\"haskell-language-server\"] = {} -- `formatter` and `setup` can be omitted\n</code></pre>"},{"location":"customization/plugins/#snippets","title":"Snippets","text":"<p>IceNvim supports VsCode-styled snippets. For example, if you want to create snippets that take effect in markdown files, you need to:</p> <ul> <li>create <code>custom/snippets/markdown.json</code></li> <li>register it in <code>custom/snippets/package.json</code></li> <li>write whatever code you like in there</li> </ul> <p>The <code>package.json</code> file looks something like this:</p> <pre><code>{\n    \"contributes\": {\n        \"snippets\": [\n            {\n                \"language\": \"markdown\",\n                \"path\": \"./markdown.json\"\n            }\n        ]\n    }\n}\n</code></pre> <p>For more information on how to write such snippets, refer to the official documentation.</p>"},{"location":"customization/plugins/#colorschemes","title":"Colorschemes","text":"<p>Conventionally, we use the <code>colorscheme</code> command to set colorschemes. In IceNvim, as you ought to remember from the utilities/keymaps section, we use the &lt;C-k&gt;&lt;C-t&gt; keymap to open a colorscheme picker. This is quite handy in that it persists across sessions. Alternatively, you can use the <code>IceColorscheme</code> command to directly set the colorscheme from the command line.</p> <p>For a colorscheme to appear in this picker or to work for the <code>IceColorscheme</code> command, you need not only to install the colorscheme plugin itself, but also register it in the <code>Ice.colorschemes</code> (notice the <code>s</code> at the end) table. Each table must have a <code>name</code> value which can be used with <code>:colorscheme name</code> and a <code>background</code> field that is either <code>\"dark\"</code> or <code>\"light\"</code>.</p> <p>Optionally you can have a <code>setup</code> field that:</p> <ul> <li>can be passed to the plugin's setup function if it is a table</li> <li>can be directly called when setting the colorscheme if it is a function</li> </ul> <p>And a <code>transparent</code> field that, if set to <code>true</code>, will trigger the <code>TransparentEnable</code> command when this colorscheme is used.</p> <p>For example:</p> <pre><code>-- gruvbox-light will appear in the colorscheme picker\nIce.colorschemes[\"gruvbox-light\"] = {\n    name = \"gruvbox\",\n    setup = {\n        italic = {\n            strings = true,\n            operators = false,\n            comments = true,\n        },\n        contrast = \"hard\",\n    },\n    background = \"light\",\n}\n\n-- When this colorscheme is used, the background will go transparent as it has `transparent = true`\nIce.colorschemes[\"monet-dark\"] = {\n    name = \"monet\",\n    transparent = true,\n    setup = function()\n        local palette = require \"monet.palette\"\n        setmetatable(palette, { __index = palette.defaults })\n    end,\n    background = \"dark\",\n},\n</code></pre> <p>If you would like a code the colorscheme in your custom config files, you can also set the colorscheme via <code>Ice.colorscheme</code>. It is a string value that is one of the available colorschemes from <code>Ice.colorschemes</code>.</p>"},{"location":"utilities/commands/","title":"Commands","text":"<p>IceNvim has created a number of commands:</p> <ul> <li><code>IceAbout</code>: opens a float window that displays the info about IceNvim</li> <li><code>IceCheckIcons</code>: opens a float window that displays a number of nerd icons; you can use this to check whether you have correctly set up your nerd font</li> <li><code>IceCheckPlugins</code>: opens a float window that displays plugins that have not been updated for more than 30 days</li> <li><code>IceColorscheme</code>: selects a IceNvim-builtin colorscheme that also takes care of things like transparency; persists across sessions</li> <li><code>IceUpdate</code>: updates IceNvim itself (not updating the plugins)</li> <li><code>IceHealth</code>: run a health check on the prerequisites for IceNvim</li> <li><code>IceRepeat</code>: make a command repeatable when creating a keymap; for instance, <code>vim.keymap.set(\"n\", \"&lt;leader&gt;zz\", \":IceRepeat :BufferLineMovePrev&lt;CR&gt;\")</code> allows you to prefix a count before &lt;leader&gt;zz </li> <li><code>IceView</code>: views the output of a command in a new buffer; for instance, <code>:IceView :lua print(123)</code> displays <code>123</code> in a new buffer; you can use this command without any argument to view the previous output generated with this command</li> </ul>"},{"location":"utilities/keymaps/","title":"Keymaps","text":"<p>IceNvim has set up a lot of reasonable and easy-to-remember keymaps already. Almost all of them can be checked out via the awesome <code>which-key.nvim</code> plugin either when you are typing them or by explicitly calling the <code>WhichKey</code> command.</p> <p>This page lists only those keymaps that IceNvim has added. Some of the default keymaps that come with plugins are not included.</p>"},{"location":"utilities/keymaps/#core-keymaps","title":"Core Keymaps","text":"<p>These keymaps do not rely on external plugins. The details can be viewed in <code>lua/core/keymap.lua</code>.</p> key description modes gcO add comment above current line normal gco add comment below current line normal gcA add comment after current line normal J if in normal mode, join <code>v_count</code> + 1 lines normal / visual \\ black hole register normal / visual &lt;A-b&gt; open current html / markdown / typst file normal &lt;A-o&gt; insert line below current line and remain in normal mode normal &lt;A-O&gt; insert line above current line and remain in normal mode normal &lt;C-g&gt; clear command line normal / insert / visual / terminal &lt;C-s&gt; save file normal / insert / visual &lt;C-t&gt; open terminal normal &lt;C-z&gt; undo normal / insert / visual / terminal / command"},{"location":"utilities/keymaps/#command-mode-keymaps","title":"Command Mode Keymaps","text":"<p>These are keymaps that are aimed at enhancing editting experience in the command line. You might notice some resemblance to emacs.</p> key description &lt;C-f&gt; move forward &lt;C-b&gt; move backward &lt;C-a&gt; start of the line &lt;C-e&gt; end of the line &lt;A-f&gt; move forward one word &lt;A-b&gt; move backward one word"},{"location":"utilities/keymaps/#plugin-related-keymaps","title":"Plugin-Related Keymaps","text":"<p>These keymaps are only available when the corresponding plugins are loaded. If you start neovim with the <code>--noplugin</code> flag, they would not work. You can check them out in <code>lua/plugins/keymap.lua</code> and <code>lua/plugins/config.lua</code>.</p> <p>These keymaps are mostly prefixed with the leader key (&lt;SPC&gt; ) and an additional key that gives you a glimpse of what the keymap might do. They include:</p> prefix group &lt;leader&gt;a avante &lt;leader&gt;b bufferline &lt;leader&gt;g git &lt;leader&gt;h hop &lt;leader&gt;l lsp &lt;leader&gt;t telescope &lt;leader&gt;u utils <p>The full list of these keymaps include:</p>"},{"location":"utilities/keymaps/#avante","title":"Avante","text":"key description modes &lt;leader&gt;awc focus selected code normal &lt;leader&gt;awi focus input normal &lt;leader&gt;awa focus result normal &lt;leader&gt;aws focus selected files normal &lt;leader&gt;awt focus todo normal"},{"location":"utilities/keymaps/#bufferline","title":"Bufferline","text":"<p>This part relies on the bufferline.nvim plugin.</p> key description modes &lt;leader&gt;bc bufferline pick close normal &lt;leader&gt;bd bufferline close current buffer normal &lt;leader&gt;bh bufferline previous buffer normal &lt;leader&gt;bl bufferline next buffer normal &lt;leader&gt;bo bufferline close other buffers normal &lt;leader&gt;bp bufferline pick buffer normal &lt;leader&gt;bm bufferline move buffer rightwards normal &lt;leader&gt;bM bufferline move buffer leftwards normal"},{"location":"utilities/keymaps/#git","title":"Git","text":"<p>This part relies on the gitsigns.nvim and neogit plugins.</p> key description modes &lt;leader&gt;gB stage buffer normal &lt;leader&gt;gb git blame normal &lt;leader&gt;gl git blame line normal &lt;leader&gt;gn go to next hunk normal &lt;leader&gt;gP preview hunk normal &lt;leader&gt;gp go to previous hunk normal &lt;leader&gt;gr restore hunk normal &lt;leader&gt;gs stage hunk normal &lt;leader&gt;gt open neogit normal &lt;leader&gt;gu undo stage normal"},{"location":"utilities/keymaps/#hop","title":"Hop","text":"<p>This part relies on the hop.nvim plugin.</p> key description modes &lt;leader&gt;hp hop word normal"},{"location":"utilities/keymaps/#lsp","title":"Lsp","text":"<p>The keymaps would only work if the corresponding lsp / formatter / ... is set up properly.</p> key description modes &lt;leader&gt;lc code action normal &lt;leader&gt;ld go to definition normal &lt;leader&gt;lf format code normal &lt;leader&gt;lh view hover doc normal &lt;leader&gt;li go to implementation normal &lt;leader&gt;ln go to next diagnostic normal &lt;leader&gt;lP show line diagnostic normal &lt;leader&gt;lp go to previous diagnostic normal &lt;leader&gt;lR show references normal &lt;leader&gt;lr rename normal &lt;leader&gt;lt toggle trouble.nvim normal &lt;leader&gt;ly yank line diagnostic normal"},{"location":"utilities/keymaps/#telescope","title":"Telescope","text":"<p>This part relies on the telescope.nvim plugin.</p> key description modes &lt;leader&gt;t&lt;C-f&gt; find in pwd normal &lt;leader&gt;tf find file normal"},{"location":"utilities/keymaps/#utils","title":"Utils","text":"key description modes &lt;leader&gt;uc select config file normal &lt;leader&gt;uf toggle nvim-tree normal &lt;leader&gt;ug use grug-far to find and replace normal &lt;leader&gt;ul open lazy panel normal &lt;leader&gt;ut find todo items normal &lt;leader&gt;uu toggle undo tree normal"},{"location":"utilities/keymaps/#misc","title":"Misc","text":"key description modes &lt;C-k&gt;&lt;C-t&gt; open colorscheme picker normal"},{"location":"utilities/plugins/","title":"Plugins","text":"<p>IceNvim uses a variety of plugins to guarantee a smooth editing experience.</p>"},{"location":"utilities/plugins/#plugin-manager","title":"Plugin Manager","text":"<p>IceNvim uses lazy.nvim as plugin manager. It is modern, powerful, and extremely easy to use.</p> <p>Beware that the way IceNvim uses Lazy is slightly different from the official approach, which we shall see later in the customization section. The majority, though, remains unchanged, which is why a little knowledge on how to use this plugin manager would be helpful should you wish to further customize Lazy in IceNvim.</p>"},{"location":"utilities/plugins/#colorscheme-and-ui","title":"Colorscheme and UI","text":"<p>IceNvim comes with the following colorschemes (and their variants; for details, check out the corresponding repositories):</p> <ul> <li>github theme</li> <li>gruvbox theme</li> <li>kanagawa theme</li> <li>miasma theme</li> <li>nightfox theme</li> <li>tokyonight theme (this is the first theme I used for neovim btw)</li> </ul> <p>As well as some other UI-related plugins, including:</p> <ul> <li>bufferline: displays opened buffers at the top</li> <li>dashboard: provides a welcome screen when opening neovim</li> <li>fidget: displays pretty notifications</li> <li>indent-blankline: adds indentation lines</li> <li>lualine: displays various info about neovim at the bottom</li> <li>nvim-scrollview: displays a scroll bar</li> <li>nvim-transparent: makes most background colors of neovim transparent</li> <li>rainbow-delimiters: use different colors for paired parentheses</li> <li>winsep: indicates the window currently being focused</li> </ul>"},{"location":"utilities/plugins/#improving-editting-experience","title":"Improving Editting Experience","text":"<p>IceNvim uses various plugins for better editting experience:</p> <ul> <li>grug-far: better find / replace</li> <li>hop: hops to the desired position with a few key presses</li> <li>nvim-autopairs: automatically closes pairs such as parentheses</li> <li>surround: surround text with parentheses or tags easily</li> <li>ufo: better folding</li> <li>undotree: visualize your edits so that you can undo them with much ease</li> </ul>"},{"location":"utilities/plugins/#useful-tools-for-development","title":"Useful Tools for Development","text":"<p>Apart from the necessary plugins for basic editting, IceNvim also includes several useful plugins that boost development efficiency:</p> <ul> <li>avante: use neovim like using using Cursor AI IDE; disabled by default</li> <li>colorizer: colorize rgb / hex / ... colors</li> <li>gitsigns: git integration for buffers</li> <li>markdown-preview: live preview for markdown files</li> <li>neogit: an extremely powerful and handy git interface</li> <li>nvim-tree: displays file tree</li> <li>nvim-treesitter: build a syntax tree and enable better highlighting, and much much more</li> <li>telescope: find, filter, preview, pick... you name it</li> <li>todo-comments: highlight todo / warn / fix / perf / ... comments</li> <li>trouble: a pretty list for showing diagnostics, references, etc.</li> </ul> <p>Auto completions, diagnostics, formatting, etc., are managed by these extra plugins:</p> <ul> <li>blink-cmp: incredibly fast completion</li> <li>mason: manage lsp / formatter sources</li> <li>null-ls: code formatter; IceNvim actually uses none-ls, a fork of the original null-ls project</li> <li>lspsaga: collection of useful lsp utilities like hover docs and displaying diagnostics</li> </ul> <p>Some languages also require extra plugins (disabled by default):</p> <ul> <li>flutter-tools.nvim: flutter development</li> <li>rustaceanvim: rust development</li> <li>typst-preview.nvim: writing with typst</li> </ul>"}]}